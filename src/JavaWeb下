1.使用el自定义函数，要导入jstl对应的jar包，有两个，jstl.jar和standard.jar，将这两个jar包放入到WEB-INF/lib下
官方下载地址如下http://archive.apache.org/dist/jakarta/taglibs/standard/binaries/，
然后在jsp页面中导入<%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions" %>
2.编写el自定义函数的步骤
    a:写一个类，定义一个public的静态方法
    b:在tld文件中进行描述
    <!--描述el自定义函数-->
        <function>
            <!--函数名-->
            <name>concat</name>
            <!--函数对应的处理类-->
            <function-class>el.MyElFunction</function-class>
            <!--方法签名-->
            <function-signature>java.lang.String concat(java.lang.String,java.lang.String)</function-signature>
        </function>
    c:在jsp页面使用
    <%@ taglib prefix="atguigu" uri="http://www.atguigu.com" %>
      ${atguigu:concat("a","b" )}
3.JSTL
    使用jstl标签库，需要先导入两个jar包
    然后在jsp页面中引入
    <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
    标签
        <c:out>用于输出变量，(比el更强大，可以对敏感的字符进行自动转换)
        三个属性：
            value:要输出的值
            default:当value为null时，显示的值
            escapeXml:是否对特殊字符转化，默认为true
        <c:set> 用来将变量存储到JSP范围或者javabean的属性中
        <c:remove> 根据变量名移除对应范围内的属性
        <c:if>没有else，但是可以把判断的结果存储起来
        <c:choose when otherwise 可以实现if else if的地址
        c:choose必须以父标签存在
        c:when和c:otherwise不能单独存在
        c:otherwise必须放在c:when之后
4.URL操作
    <c:import>可以包含任何页面
      <c:redirect url="/jstl/jstl.jsp"/>  斜杠代表的是当前Web应用的根目录
      <c:url/> 产生一个url地址，可以根据cookie是否可用来智能进行url重写，对get请求的参数进行编码
        可以把产生的url存储在域对象的属性中

    数据库删除语句：delete from customer where name = 'xxx';
    模糊查询：select * from customer where name like '%%';(查询所有的)

  Filter
        拦截请求和响应
        需要在web.zml中配置和映射
  如何实现Filter
    当前类实现Filter接口，重写三个方法
    init
    doFilter
    destroy
    FilterChain Filter链，多个Filter构成一个Filter链
        doFilter:把当前请求传给下一个Filter,若当前Filter是最后一个，把请求给目标Servlet(JSP)
        多个Filter的拦截顺序和Filter在web.xml中<filter-mapping的>配置顺序有关

    多个Filter的代码执行顺序：
        假如有两个Filter,(A filter的filter-mapping配置在B的前面)目标页面是test.jsp,则代码的执行顺序是
        1，3，5，4，2
        A:
            System.out.println("before A filter");//1
            chain.doFilter
            System.out.println("before A filter");//2
         B:
             System.out.println("before B filter");//3
             chain.doFilter
             System.out.println("before B filter");//4

             test.jsp//5

      dispatcher节点，指定过滤器所拦截的资源被Servlet容器调用的方式，有REQUEST,FORWARD,INCLUDE,ERROR
         <filter-mapping>
                    <filter-name>HelloFilter</filter-name>
                    <url-pattern>/filter/test.jsp</url-pattern>
                    <dispatcher>FORWARD</dispatcher>
                </filter-mapping>
        指定错误处理的两种方式
            a:errorPage指定
            <%@ page contentType="text/html;charset=UTF-8" language="java" errorPage="test.jsp" %>
            b:在web.xml里配置
                     <error-page>
                        <exception-type>java.lang.ArithmeticException</exception-type>
                        <location>/filter/test.jsp</location>
                    </error-page>
        缓存案例
            //禁用浏览器的缓存
            response.setDateHeader("Expires",-1);
            response.setHeader("Cache-Contrl","no-cache");
            response.setHeader("Pragma","no-cache");
